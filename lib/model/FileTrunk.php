<?php

require 'plugins/sfFileTrunkPlugin/lib/model/om/BaseFileTrunk.php';


/**
 * Skeleton subclass for representing a row from the 'file_trunk' table.
 *
 *
 *
 * This class was autogenerated by Propel 1.4.0 on:
 *
 * Sun Jan  3 06:35:37 2010
 *
 * You should add additional methods to this class to meet the
 * application requirements.  This class will only be generated as
 * long as it does not already exist in the output directory.
 *
 * @package    plugins.sfFileTrunkPlugin.lib.model
 */
class FileTrunk extends BaseFileTrunk {

	protected $img_types = array(
    'image/jpeg',
    'image/pjpeg',
    'image/png',
    'image/gif',
	);

	public static function getPath()
	{
		return sfConfig::get('sf_upload_dir');
	}

	/**
	 * Generates a thumbnail filename from the actual name
	 * 
	 * @param int $width
	 * @param int $height
	 * @param string $method
	 * @return string
	 */
	protected function generateThumbnailName($width, $height, $method = 'fit')
	{
		// prepare regular expression to construct a thumbnail filename
		// {actualname}-{width}x{height}.{method}.{extension}
		$thumb_regexp = '/([^.]*)\.(.*)?/';
		$thumb_replace = sprintf('$1-%dx%d-%s.$2', $width, $height, $method);
		
		return preg_replace($thumb_regexp, $thumb_replace, $this->getActualName());
	}
	
	/**
	 * Method to retrieve files related to the current instance
	 * 
	 * @return array An array of all related files to this file trunk object
	 */
	protected function getRelatedFiles()
	{
		// we need to first delete all files associated with the FileTrunk object
		$file_name_only = substr( $this->getActualName(), 0, strrpos( $this->getActualName(), '.' ) ) . '*';
		// since we might have thumbnails we have to find all files that begin with the actual name
		return sfFinder::type( 'file' )->name( $file_name_only )->in( self::getPath() );
	}

	/**
	 * This method generates a thumbnail if the file in the trunk is of any of the supported image mime-types
	 * 
	 * @throws Exception, InvalidArgumentException
	 * 
	 * @param int $width max width of thumbnail
	 * @param int $height max height of thumbnail
	 * @param string $method (optional)
	 * @param mixed $background (optional)
	 * @param int $quality (optional) sets the quality of the thumbnail
	 * 
	 * @return string Returns the path of the generated thumbnail
	 */
	public function generateThumbnail($width, $height, $method='fit', $background=null, $quality = 75)
	{
		// Let's first see if the mime-type is an image mime-type
		// If the mime-type is not supported we will throw an exception 
		if (!in_array($this->getMimeType(), $this->img_types))
		{
			throw new Exception(sprintf('Image MIME type %s not supported', $this->getMimeType()));
		}
		
		// Now we validate the width and the height.
		// Currently only a range from 5 to 1000 pixels (inclusive) is allowed
		// If the values are invalid we will throw an InvalidArgument
		if ($width >= 5 && $width <= 1000 && $height >= 5 && $height <= 1000)
		{
			// get our file name with path
			$filename = self::getPath().DIRECTORY_SEPARATOR.$this->getActualName();
			
			// get our thumbnail file name with path 	
			$thumb_filename = self::getPath().DIRECTORY_SEPARATOR.$this->generateThumbnailName($width, $height, $method);
			
			// Let us check first if the thumbnail already exists
			// If it doesn't exist then we will generate and save it
			if (!file_exists($thumb_filename))
			{
				// The file does not exist. For security reasons we have to check that no other thumbnail
				// From the same file has been created in the past 30 minutes. This check is disabled in the dev environment
				if (sfConfig::get('sf_environment') != 'dev')
				{
					$compare_time = strtotime('-30 minutes');
					$files = $this->getRelatedFiles();
					$original_file = self::getPath().DIRECTORY_SEPARATOR.$this->getActualName();
					foreach ($files as $file)
					{
						// if we have found a file that has been created in the past 30 minutes
						// we will return it as the thumbnail.
						if ($file != $original_file && filemtime($file) > $compare_time )
						{
							return $file;
						}
					}
				}
				
				// now we will create the thumbnail from our original file and save it
				$img = new sfImage($filename, $this->getMimeType());
				$img->thumbnail($width, $height, $method, $background);
				$img->setQuality($quality);
				$img->saveAs($thumb_filename);
				
				/*$thumb = new sfThumbnail($width, $height, $scale, $inflate, $quality);
				$thumb->loadFile($filename);
				$thumb->save($thumb_filename);*/
			}
			
			// At last we return the thumbnail filepath
			return $thumb_filename;
		}
		throw new InvalidArgumentException(sprintf('Width and height are invalid. %d and %d given respectively', $width, $height));
	}

	public function __toString()
	{
		return $this->getOriginalName();
	}
	
	/**
	 * Persists this object to the database.
	 *
	 * If the object is new, it inserts it; otherwise an update is performed.
	 * All modified related objects will also be persisted in the doSave()
	 * method.  This method wraps all precipitate database operations in a
	 * single transaction.
	 *
	 * @param      PropelPDO $con
	 * @return     int The number of rows affected by this insert/update and any referring fk objects' save() operations.
	 * @throws     PropelException
	 * @see        doSave()
	 */
	public function save(PropelPDO $con = null)
	{
		// First we need to check if the current object is new. Only new FileTrunk object may be saved.
		// Update of file trunk objects is not supported
		if (!$this->isNew())
		{
			throw new PropelException('FileTrunk objects cannot be updated. Only newly created or deleted');
		}
		
		// Now we have to check if the file actually exists. If not we will throw another exception
		$filename = self::getPath().DIRECTORY_SEPARATOR.$this->getActualName();
		if (!file_exists($filename))
		{
			throw new PropelException('FileTrunk file could not be found. FileTrunk objects have to be created through file upload using sfValidatedFileTrunk class.');
		}
		parent::save($con);
	}
	/**
	 * Removes this object from datastore and sets delete attribute.
	 *
	 * @param      PropelPDO $con
	 * @return     void
	 * @throws     PropelException
	 * @see        BaseObject::setDeleted()
	 * @see        BaseObject::isDeleted()
	 */
	public function delete(PropelPDO $con = null)
	{
		// Get all related files
		$files = $this->getRelatedFiles();

		// now we loop through all the found files and try to delete them
		foreach ( $files as $file )
		{
			@unlink( $file );
		}
		parent::delete( $con );
	}
} // FileTrunk
